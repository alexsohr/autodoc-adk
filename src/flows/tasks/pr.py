from __future__ import annotations

import logging
import uuid
from pathlib import Path

from prefect import task

from src.database.models.repository import Repository
from src.errors import TransientError
from src.providers.base import get_provider
from src.services.config_loader import AutodocConfig

logger = logging.getLogger(__name__)


@task(name="close_stale_autodoc_prs")
async def close_stale_autodoc_prs(
    *,
    repository: Repository,
    branch: str,
) -> int:
    """Close open autodoc PRs matching branch pattern ``autodoc/{repo_name}-{branch}-*``.

    Returns count of closed PRs.
    """
    provider = get_provider(repository.provider)
    branch_pattern = f"autodoc/{repository.name}-{branch}-"

    count = await provider.close_stale_prs(
        url=repository.url,
        branch_pattern=branch_pattern,
        access_token=repository.access_token,
    )
    logger.info("Closed %d stale autodoc PRs for %s/%s", count, repository.name, branch)
    return count


@task(name="create_autodoc_pr", retries=1, retry_delay_seconds=5)
async def create_autodoc_pr(
    *,
    repository: Repository,
    branch: str,
    job_id: uuid.UUID,
    readme_content: str,
    repo_path: str,
    config: AutodocConfig,
) -> str:
    """Create autodoc PR with README content.

    1. Create branch: ``autodoc/{repo_name}-{branch}-{job_id_short}-{YYYY-MM-DD}``
    2. Write README to configured ``output_path``
    3. Commit and push
    4. Create PR targeting default branch (``public_branch``)

    Returns PR URL.
    """
    import asyncio
    from datetime import UTC, datetime
    from urllib.parse import urlparse

    provider = get_provider(repository.provider)
    today = datetime.now(tz=UTC).strftime("%Y-%m-%d")
    job_short = str(job_id)[:8]
    pr_branch = f"autodoc/{repository.name}-{branch}-{job_short}-{today}"

    # Write README file, commit, and push using git subprocess
    readme_path = Path(repo_path) / config.readme.output_path
    readme_path.parent.mkdir(parents=True, exist_ok=True)
    readme_path.write_text(readme_content, encoding="utf-8")

    # Git operations
    async def _git(*args: str) -> str:
        proc = await asyncio.create_subprocess_exec(
            "git",
            *args,
            cwd=repo_path,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
        stdout, stderr = await proc.communicate()
        if proc.returncode != 0:
            raise TransientError(f"git {args[0]} failed: {stderr.decode()}")
        return stdout.decode().strip()

    await _git("checkout", "-b", pr_branch)
    await _git("add", config.readme.output_path)
    await _git("commit", "-m", f"docs: update documentation for {branch}")

    # Push â€” inject token for auth
    push_url = repository.url
    if repository.access_token:
        parsed = urlparse(repository.url)
        if repository.provider == "github":
            push_url = (
                f"https://{repository.access_token}@{parsed.hostname}{parsed.path}"
            )
        else:  # bitbucket
            push_url = (
                f"https://x-token-auth:{repository.access_token}"
                f"@{parsed.hostname}{parsed.path}"
            )

    await _git("push", push_url, pr_branch)

    pr_url = await provider.create_pull_request(
        url=repository.url,
        branch=pr_branch,
        target_branch=repository.public_branch,
        title=f"docs: update documentation for {branch}",
        body=(
            f"Automated documentation update generated by AutoDoc.\n\n"
            f"Job ID: {job_id}\n"
            f"Branch: {branch}"
        ),
        access_token=repository.access_token,
        reviewers=config.pull_request.reviewers or None,
        auto_merge=config.pull_request.auto_merge,
    )

    logger.info("Created PR: %s", pr_url)
    return pr_url
